astuces JSF 

- FacesContext est le composant magique de JSF. Il recense tous les composants d'une vue ains que les msgs qui leur sont associés

- <h:messages globalOnly="true" id="xxx" /> ==> permet dafficher tous les msgs de la vue (meme ceux deja affcihes par <h:message /> )
  On peut egalement lui passer un msg d'erreur venant d'un comôsant qui n'est pas sur la vue. Cela se fait en pasant l'argument NULL dans 
  FacesContext.addMessage(null, message);

- Les messages en JSF

  FacesMessage message = new FacesMessage("Je suis le Msg");
  FaceMessage.setSeverity(FaceMessage.SEVERITY_INFO); ==> SEVERITY_WARN, SEVERITY_ERROR, SEVERITY_FATAL
  FaceMessage.setSummary("le resumé");
  FaceMessage.setDetail("les details"); ==> ds ce cas declarer avec FaceMessage msg = new faceMessage();
  //pour afficher le msg
  FacesContext.getCurrentInstance().addMessage('ID_Composant', message);


- <h:inputSecret id="mon_Id" value="metode_managed" label="en cas d'erreur ce qu'il faut afficher à la place de 'ID du champ" 
  requiredMessage="Message a aficher en cas de champ vide" />

- charger bundles 

  créer un fichier .properties (ici messages.properties
  <h:head >
	<f:loadBundle basename="com.bj.bundle.messages" var="msg" />

  </h:head>

- gestion des msgs avec Ajax
  
  <h:inputText id="" value="" ... >
	<f:ajax event="blur" render='champ message a reafficher' />
  </h:inputText>

 
- on peut faire @This ==> pour le champ
		@form ==>  pour le formulaire
	        @all ==> pour tous les composants de la page
		@none ==> na designe aucun comopsant


- la gestion des fichiers (envoi) ==> utiliser fileUpload de PrimeFaces

- gestion des formats
  La balise core peut etre utilisée



 <h:outputText id=""  value="">
	<core:convertNumber type="currency" ou type="percent" currencyCode="EUR" minFractionDigits="3" />
 </h:outputText>


<h:outputText id=""  value="">
	<core:convertNumber integerOnly="true" />
 </h:outputText>

<h:outputText id=""  value="">
	<core:convertNumber pattern="#.##" />
 </h:outputText>


<h:outputText id=""  value="">
	<core:convertDateTime pattern="EEE, dd/MM/yy" />
 </h:outputText>


- Les liens (On peut envoyer un parametre au moment du clic)

<h:commanLink>
	<h:outputText value="Selectionner" />
	<f:param name="id" value="1" />
</h:commandLink>


<h:commanLink>
	<h:graphicImage value="/images/ben.jpg" />
	<f:param name="id" value="1" />
</h:commandLink>


- les cases à cocher

<h:selectManyCheckBox layout="PageDirection" >
	<f:selectItem itemValue="petit" itemLabel="Petit" />
	<f:selectItem itemValue="moyen" itemLabel="Moyen" />
	<f:selectItem itemValue="grand" itemLabel="Grand" />
	<f:selectItem itemValue="tresgrand" itemLabel="Très Grand" />
</h:selectManyCheckBox>


- Les boutons radio

<h:selectOneRadio layout="PageDirection" >
	<f:selectItem itemValue="petit" itemLabel="Petit" />
	<f:selectItem itemValue="moyen" itemLabel="Moyen" />
	<f:selectItem itemValue="grand" itemLabel="Grand" />
	<f:selectItem itemValue="tresgrand" itemLabel="Très Grand" />
</h:selectOneRadio>



Dans les beans, il faut remplir des SelectItem comme ceci (avec un bean qui gere les tailles)

private SelectItem[] tabselectitem = {
	new SelectItem (new Integer(1), "Petit"),
	new SelectItem (new Integer(2), "moyen"),
	new SelectItem (new Integer(3), "Grand"),
	new SelectItem (new Integer(4), "Très Grand")
	}

on peut aussi passer faire comme ceci. Dans ce cas, il faut une methode getTaille pour obtenir la valeur de l'elmt choisi

private Integer taille = null;

//getter et setter pour taille

public Integer getTaille(){
	return taille;
}


punlic void setTaille(Integer newTaille){
	this.taille = newTaille;
}

<h:selectOneRadio value="#{lebean.taille}" layout="PageDirection" >
	<f:selectItems value="#{le.bean.qui.renvoit.les.SelectItems}" />
</h:selectOneRadio>


- Choix multiple dans une liste

Cette fois-ci l'elmt renvoye est un tableau ou une liste (ici ex. avec tableau)

private String [] idTab = {"moyen","grand"};

// les getter et setter pour idTab

public String[] getIdTab(){
	return idTab;
}

public void setIdTab(String[] newIdtab){
	this.idTab = newIdTab;
}


private SelectItem[] tabselectitem = {
	new SelectItem ("petit", "Petit"),
	new SelectItem ("moyen", "moyen"),
	new SelectItem ("grand", "Grand"),
	new SelectItem ("tresgrand", "Très Grand")
	}


<h:selectManyListBox value="#{lebean.taille}" layout="PageDirection" >
	<f:selectItems value="#{le.bean.qui.renvoit.les.SelectItems}" />
</h:selectManyListBox>


- Pour les listes deroulantes

<h:selectManyMenu value="#{lebean.taille}" layout="PageDirection" >
	<f:selectItems value="#{le.bean.qui.renvoit.les.SelectItems}" />
</h:selectManyMenu>

- La gestion des evenements

<h:selectOneRadio value="#{lebean.taille}" valuechangeListener="#{methode.pour.cgmt.evenement}" layout="PageDirection" >
	<f:selectItems value="#{le.bean.qui.renvoit.les.SelectItems}" />
</h:selectOneRadio>

dans le bean 

public void langueChgmt(ValueChangeEvent event) {

	FacesContext context = FacesContext.getCurrentInstance();
	if(languedefaut.equals(event.getNewValue()){
	context.getViewRoot().setLocale(Locale.FRENCH);
	else{
	context.getViewRoot().setLocale(Locale.ENGLISH);
	}
    }

}



<h:commandButton value = "" actionListener= "#{lebean.qui.traite.levement}" />

dans le bean

public void traiterActio(ActionEvent event){
	FacesContext context = FacesContext.getCurrentInstance();
	//obtenir l'Id du composant qui a declenche l'action
	String clientID = event.getComponent().getClientId(context);
	System.Out.println("l'ID du client est :" + clientID);
}



- immediate="true" ==>permet de declencher l'action du listener du composant sans que les problemes de validation 
  des autres composants ne s'en melent.

Les PickLists

<p:pickList id="pickList4" value="#{pickListBean.players}" var="player" itemLabel="#{player}" itemValue="#{player}" converter="playerConverter">
    <p:ajax event="transfer" listener="#{pickListBean.onTransfer}" update="msg" />
    <p:column style="width:75%;">  
            #{player.name}  
    </p:column>
    <p:column style="width:75%;">  
            #{player.number}  
    </p:column>
</p:pickList>

public void onTransfer(TransferEvent event) {
    selectedPlayerNames = "";
    for (Player p : players.getTarget()){
        selectedPlayerNames += p.getName() + " ";
        }
}


// utlisation de sequences 	

@Entity
@Table(name="PERSONNE")
@SequenceGenerator(name="PERSONNE_SEQUENCE",
sequenceName="PERSONNE_SEQ")
public class Personne implements Serializable {
  @Id
  @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="PERSONNE_SEQUENCE")
  private int id;


//les queries 

package com.jmdoudoux.test.jpa;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;

public class TestJPA7 {
  public static void main(String[] argv) {
    EntityManagerFactory emf = Persistence
        .createEntityManagerFactory("MaBaseDeTestPU");
    EntityManager em = emf.createEntityManager();

    Query query = em.createQuery("select p from Personne p where p.nom='nom2'");
    Personne personne = (Personne) query.getSingleResult();
    if (personne == null) {
      System.out.println("Personne non trouvée");
    } else {
      System.out.println("Personne.nom=" + personne.getNom());
    }

    em.close();
    emf.close();
  }
}


//autre exemple

package com.jmdoudoux.test.jpa;

import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;

public class TestJPA9 {
  public static void main(String[] argv) {
    EntityManagerFactory emf = Persistence
        .createEntityManagerFactory("MaBaseDeTestPU");
    EntityManager em = emf.createEntityManager();

    Query query = em.createQuery("select p.nom from Personne p where p.id > :id");
    query.setParameter("id", 1);
    List noms = query.getResultList();
    for (Object nom : noms) {
      System.out.println("nom = "+nom);
    }
    
    em.close();
    emf.close();
  }
}


















